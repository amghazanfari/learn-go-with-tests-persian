# اعداد صحیح

**[شما می‌توانید کدهای این بخش را اینجا ببینید](https://github.com/quii/learn-go-with-tests/tree/main/integers)**

اعداد صحیح همانطور که انتظار دارید کار می‌کنند. بیایید یک تابع `Add` بنویسیم تا این اعداد را بررسی کنیم. یک فایل تست با نام `adder_test.go` بسازید تا تست‌ها را در آن بنویسیم.


**یادداشت:** گو به شکلی هست که در هر فولدر تنها یک بسته می‌تواند باشد برای اطلاعات بیشتر می‌توانید به. [اینجا](https://dave.cheney.net/2014/12/01/five-suggestions-for-setting-up-a-go-project) مراجعه کنید.

ساختار پروژه‌ی شما باید شبیه به شکل زیر باشد

```
learnGoWithTests
    |
    |-> helloworld
    |    |- hello.go
    |    |- hello_test.go    
    |
    |-> integers
    |    |- adder_test.go
    |
    |- go.mod
    |- README.md
```

## اول، نوشتن تست

```go
package integers

import "testing"

func TestAdder(t *testing.T) {
	sum := Add(2, 2)
	expected := 4

	if sum != expected {
		t.Errorf("expected '%d' but got '%d'", expected, sum)
	}
}
```
اگر متوجه شده باشید ما به جای `%q` از `%d` استفاده می‌کنیم. این بخاطر این است که می‌خواهیم به جای رشته از عدد صحیح استفاده کنیم.

و همینطور نکته‌ی دیگر این هست که ما از بسته‌ی main استفاده نمی‌کنیم و بسته‌ی جدید integers نام دارد، و همانطور که از نامش مشخص است این بسته برای کار با اعداد صحیح است.

## تست را اجرا کنید

تست را با دستور `go test` اجرا کنید

خطای زمان کامپایل را بررسی کنید

`./adder_test.go:6:9: undefined: Add`

## کمترین میزان کد برای ران شدن تست و دیدن خطای تست را بنویسید

به اندازه‌ای تست بنویسید که خطای کامپایل برطرف شود و نه بیشتر، به یاد داشته باشید که ما به دلیل موجه‌ای می‌خواهیم که تستمان خطا بدهد

```go
package integers

func Add(x, y int) int {
	return 0
}
```

زمانی که بیش از یک متغیر از یک نوع دارید (برای مورد ما دو متغیر int) می‌توانیم به جای نوشتن به این شکل `(x int, y int)` از فرم کوتاه شده‌ی آن استفاده کنیم `(x, y int)`.

حالا تست را اجرا کنید، در اینجا همانطور که انتظار می‌رفت متن خطا را می‌بینیم.

`adder_test.go:10: expected '4' but got '0'`

اگر به خاطر داشته باشید در فصل قبلی در [اینجا](hello-world.md#one...last...refactor?) با مفهوم متغیر  بازگشتی دارای نام آشنا شدیم، اما اینجا از آن استفاده نکردیم. این متغیر زمانی استفاده می‌شود که معنی مقدار بازگشتی به درستی از روی خود تابع قابل فهم نیست، اما در این مورد تقریبا مشخص است که چه چیزی می‌خواهیم برای اطلاعات بیشتر به [این](https://github.com/golang/go/wiki/CodeReviewComments#named-result-parameters) ویکی مراجعه کنید.

## نوشتن کد به اندازه‌ای که تست‌ها پاس شوند

تو سخت‌گیرانه‌ترین حالت برنامه‌نویسی تست محور ما باید کمترین کد ممکن برای اجرای تست را بنویسیم. یک برنامه‌نویسی که مو را از ماست بیرون می‌کشد ممکن است چنین چیزی بنویسد

```go
func Add(x, y int) int {
	return 4
}
```

با این می‌شود تست را پاس کرد، در صورتی که درست نیست. آیا مشکل از این روش است؟

ما می‌توانیم اعداد دیگری بگذارید و تست را لا آن اجرا کنیم اما این دنباله قرار نیست پایان پیدا کند.

زمانی که بیشتر با سینتکس گو آشنا شدیم، من تست ویژگی محور را معرفی خواهم کرد، که به این کار خاتمه می‌دهد و به شما کمک می‌کند باگ را پیدا کنید.

فعلا اجازه دهید به روش درستی این مشکل را حل کنیم
```go
func Add(x, y int) int {
	return x + y
}
```

اگر دوباره تست را اجرا کنید باید پاس شود

## ری‌فکتور

چیز مهمی را نمی‌توان اینجا بهبود بخشید

ما قبلا دیدیم که چگونه با نام‌گذاری مقدار بازگشتی تابع به خوانایی بیشتر کد کمک می‌کنیم.

این عالی است چرا که کمک می‌کند کد شما به درستی استفاده شود. خوب است که کاربر با نگاه کردن به تابعتان بداند کاربرد تابع چیست.

شما می‌توانید با کامنت گذاری کاربرد تابع مورد نظر را مستند کنید.

```go
// Add takes two integers and returns the sum of them.
func Add(x, y int) int {
	return x + y
}
```

### مثال

اگر می‌خواهید سنگ تمام بگذارید می‌توانید [مثال](https://blog.golang.org/examples) بسازید. شما مثال‌های زیادی در داکیومنت گو می‌بینید

معمولا کدهایی که برای نمونه در خارج از سورس کد هستند، مانند نمونه‌ی داخل readme، به دلیل آپدیت نشدن بعد از مدتی منسوخ می‌شوند.

مثال در گو همچون تست اجرا می‌شود پس شما می‌توانید از درستی آن مطمئن باشید.

مثال به عنوان بخشی از تست کامپایل می‌شود(و گاهی اوقات اجرا).

مثال مانند تست در فایل تست قرار می‌گیرد و تابع آن به جای `Test` با `Example` شروع می‌شود.

```go
func ExampleAdd() {
	sum := Add(1, 5)
	fmt.Println(sum)
	// Output: 6
}
```

(اگر ادیتور شما به شکل خودکار بسته‌ها رادر کدتان ایمپورت نمی‌کند احتمالا شما بخاطر نبود خط `import "fmt"` در `adder_test.go` به خطا می‌خورید.  بهتر است این مورد را پیگیری کنید و این قابلیت را به ادیتور خود اضافه کنید.)

اگر کدتان جوری تغییر کند که مثال دیگر قابل استفاده نباشد کد شما بیلد نمی‌شود.

زمانی که تست‌ها را اجرا می‌کنیم می‌بینیم که مثال‌ها هم در کنار تست اجرا می‌شود.

```bash
$ go test -v
=== RUN   TestAdder
--- PASS: TestAdder (0.00s)
=== RUN   ExampleAdd
--- PASS: ExampleAdd (0.00s)
```

به یاد داشته باشید که اگر مقدار `// Output: 6` را وارد نکنید مثال شما اجرا نمی‌شود. البته تابع همیشه کامپایل می‌شود در این مورد تنها اجرا نمی‌شود.

با اضافه کردن مثال، تابع نوشته شده در `godoc`, دیده خواهد شد

برای دیدن آن دستور `godoc -http=:6060` را وارد کنید و به آدرس روبرو بروید `http://localhost:6060/pkg/`

در اینجا لیستی از مستندات می‌بینید که مستندات بسته‌ی شما هم در آن است.

اگر شما کدهای خود را با مثال در یک آدرس عمومی منتشر کنید, می‌توانید مستندات خود را در [pkg.go.dev](https://pkg.go.dev/) ببینید. برای مثال در [اینجا](https://pkg.go.dev/github.com/quii/learn-go-with-tests/integers/v2) مستندات نهایی کد مربوط به این درس را می‌توانید ببینید.

## جمع‌بندی

مسائلی که تا به اینجا بررسی کردیم:

* تمرین بیشتر در حوزه‌ی برنامه‌نویسی تست محور
* اعداد صحیح و جمع کردن
* نوشتن مستندات بهتر تا دیگران کد ما را سریع‌تر بفهمند
* استفاده از مثال برای فهمیدن بهتر کد
